---
title: "Jotai 내부 동작 원리"
date: 2026/02/18
description: "Jotai의 atom, store, 의존성 그래프, React 통합까지 소스코드 레벨에서 분석"
tag: llm-study, React, Jotai, StateManagement
author: Claude Opus 4.6
---

# Jotai 내부 동작 원리

## 1. 서론

이 글은 Jotai v2.17.1 소스코드를 직접 읽고, 내부 동작 메커니즘을 분석한 결과이다. 핵심 파일은 `vanilla/atom.ts`, `vanilla/internals.ts`, `react/Provider.ts`, `react/useAtomValue.ts`, `react/useSetAtom.ts`이다. 모든 인용은 해당 버전의 실제 코드에 기반한다.

## 2. atom() — 설정 객체 생성

`atom()` 함수는 상태 컨테이너가 아닌 **설정 객체(config object)**를 반환한다. 실제 상태는 Store에 저장된다.

```ts
// [focus:3,5,10-13,15-17]
let keyCount = 0

export function atom(read?, write?) {
  const key = `atom${++keyCount}`
  const config = {
    toString() {
      return import.meta.env?.MODE !== 'production' && this.debugLabel
        ? key + ':' + this.debugLabel
        : key
    },
  }
  if (typeof read === 'function') {
    config.read = read
  } else {
    config.init = read
    config.read = defaultRead
    config.write = defaultWrite
  }
  if (write) {
    config.write = write
  }
  return config
}
```

글로벌 `keyCount`로 모든 atom에 고유 키를 부여한다. TypeScript 오버로드는 4가지: writable derived, read-only derived, write-only derived, primitive atom이다.

`defaultRead`는 `get(this)`로 자기 자신의 값을 읽고, `defaultWrite`는 `set(this, arg)`로 값을 직접 설정한다:

```ts
function defaultRead(this: Atom<Value>, get: Getter) {
  return get(this)
}

function defaultWrite(this, get, set, arg) {
  return set(this, typeof arg === 'function' ? arg(get(this)) : arg)
}
```

즉 primitive atom의 `read`/`write`는 자기 참조(`this`)를 통해 동작한다.

## 3. Store — 3개의 공개 API와 BuildingBlocks

Store는 `get`, `set`, `sub` 3개의 메서드만 외부에 노출한다:

```ts
function buildStore(...buildArgs): Store {
  const store = {
    get(atom) { return storeGet(store, atom) },
    set(atom, ...args) { return storeSet(store, atom, ...args) },
    sub(atom, listener) { return storeSub(store, atom, listener) },
  }
  // ...
}
```

내부적으로 `BuildingBlocks`라는 25개 슬롯의 튜플이 Store의 모든 상태와 함수를 관리한다. 슬롯 0~6은 상태(atomStateMap, mountedMap, invalidatedAtoms, changedAtoms, mountCallbacks, unmountCallbacks, storeHooks), 7~10은 atom 인터셉터, 11~24는 내부 함수이다.

```ts
type BuildingBlocks = [
  atomStateMap: AtomStateMap,       // 0 - WeakMap<Atom, AtomState>
  mountedMap: MountedMap,           // 1 - WeakMap<Atom, Mounted>
  invalidatedAtoms: InvalidatedAtoms, // 2
  changedAtoms: ChangedAtoms,       // 3 - Set<Atom>
  // ... 총 25슬롯
]
```

`atomStateMap`과 `mountedMap`은 모두 `WeakMap` 기반이다. atom 객체에 대한 강한 참조가 사라지면 해당 상태도 GC 대상이 된다. `buildingBlockMap` 역시 `WeakMap<Store, BuildingBlocks>`로, Store 자체의 메모리 누수를 방지한다.

## 4. AtomState & Epoch — 변경 감지의 핵심

각 atom의 런타임 상태는 `AtomState` 타입으로 관리된다:

```ts
type AtomState<Value> = {
  readonly d: Map<AnyAtom, EpochNumber>  // 의존성 → epoch
  readonly p: Set<AnyAtom>               // pending promise 의존자
  n: EpochNumber                         // 자신의 epoch
  v?: Value                              // 값
  e?: AnyError                           // 에러
}
```

`n`(epoch number)이 변경 감지의 핵심이다. `setAtomStateValueOrPromise`에서 `Object.is`로 이전 값과 비교하여, 다를 때만 epoch를 증가시킨다:

```ts
if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
  ++atomState.n
}
```

의존성 맵 `d`는 `Map<Atom, EpochNumber>` 형태로, 의존하는 atom과 그 당시의 epoch를 함께 저장한다. 이후 재계산 시 의존성의 현재 epoch와 저장된 epoch를 비교하여 캐시 유효성을 판단한다.

## 5. 의존성 그래프 — getter를 통한 자동 수집

`readAtomState` 내부에서 atom의 `read` 함수에 전달되는 `getter`가 의존성을 자동 수집한다:

```ts
// [focus:2-4,7,10]
function getter(a) {
  if (a === atom) {
    // 자기 자신 읽기: init 값 반환
    return returnAtomValue(ensureAtomState(store, a))
  }
  const aState = readAtomState(store, a)
  try {
    return returnAtomValue(aState)
  } finally {
    atomState.d.set(a, aState.n)  // 의존성 등록
  }
}
```

매 `read` 호출 시 `atomState.d.clear()`로 의존성을 초기화한 뒤, getter 호출마다 `d.set(a, aState.n)`으로 재수집한다. 캐시 전략은 두 가지이다:

1. **마운트된 atom**: `mountedMap`에 존재하고 invalidate되지 않았으면 캐시 사용
2. **미마운트 atom**: 모든 의존성의 epoch가 변하지 않았으면 캐시 사용

```ts
if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {
  return atomState  // 캐시 히트
}
```

## 6. Write Path — 쓰기와 전파

`store.set` 호출 시 실행 경로는 `storeSet → writeAtomState → recomputeInvalidatedAtoms → flushCallbacks`이다.

`writeAtomState` 내부의 `setter`에서 primitive atom에 직접 쓸 경우:

```ts
setAtomStateValueOrPromise(store, a, v)
mountDependencies(store, a)
if (prevEpochNumber !== aState.n) {
  changedAtoms.add(a)
  invalidateDependents(store, a)
}
```

`invalidateDependents`는 DFS로 모든 의존자를 순회하며 `invalidatedAtoms`에 등록한다:

```ts
const stack = [atom]
while (stack.length) {
  const a = stack.pop()
  for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
    invalidatedAtoms.set(d, dState.n)
    stack.push(d)
  }
}
```

이후 `recomputeInvalidatedAtoms`는 **위상 정렬(topological sort)**로 올바른 순서로 재계산한다. DFS로 `topSortedReversed` 배열을 구성한 뒤 역순 순회하며, 변경된 의존성이 있는 atom만 `readAtomState`를 호출한다:

```ts
for (let i = topSortedReversed.length - 1; i >= 0; --i) {
  const [a, aState] = topSortedReversed[i]
  let hasChangedDeps = false
  for (const dep of aState.d.keys()) {
    if (dep !== a && changedAtoms.has(dep)) {
      hasChangedDeps = true
      break
    }
  }
  if (hasChangedDeps) {
    readAtomState(store, a)
    mountDependencies(store, a)
  }
}
```

## 7. Mount/Unmount — 구독 생명주기

atom이 `store.sub`를 통해 구독되면 "마운트"된다. `Mounted` 타입은 4개의 필드를 갖는다:

```ts
type Mounted = {
  readonly l: Set<() => void>  // 리스너
  readonly d: Set<AnyAtom>     // 마운트된 의존성
  readonly t: Set<AnyAtom>     // 이 atom에 의존하는 atom들
  u?: () => void               // onUnmount 콜백
}
```

`mountAtom`은 재귀적으로 의존성을 먼저 마운트한 뒤 자신을 마운트한다. `onMount` 콜백은 `mountCallbacks` Set에 추가되어 `flushCallbacks`에서 실행된다.

`unmountAtom`은 리스너가 없고(`l.size === 0`) 다른 마운트된 atom의 의존성이 아닐 때만 언마운트한다:

```ts
if (!mounted || mounted.l.size) return mounted
let isDependent = false
for (const a of mounted.t) {
  if (mountedMap.get(a)?.d.has(atom)) {
    isDependent = true
    break
  }
}
if (!isDependent) {
  mountedMap.delete(atom)
  // 의존성도 재귀적으로 언마운트
}
```

`mountedMap`이 `WeakMap`이므로, 언마운트 후 atom 참조가 사라지면 `Mounted` 객체와 `AtomState` 모두 GC된다.

## 8. React 통합 — Provider, useAtomValue, useSetAtom

`Provider`는 React Context로 Store를 주입한다. store prop이 없으면 `useRef`로 한 번만 `createStore()`를 호출한다:

```ts
export function Provider({ children, store }) {
  const storeRef = useRef(null)
  if (store) {
    return createElement(StoreContext.Provider, { value: store }, children)
  }
  if (storeRef.current === null) {
    storeRef.current = createStore()
  }
  return createElement(StoreContext.Provider, { value: storeRef.current }, children)
}
```

`useStore`는 `useContext(StoreContext) || getDefaultStore()`로 Store를 반환한다. Provider 없이도 전역 기본 Store를 사용할 수 있다.

`useAtomValue`는 `useReducer`로 값을 관리하고, `useEffect`에서 `store.sub`로 구독한다. 함수 전체를 보면:

```ts
// [focus:5,7-9,15,22-24,30-31,34-37]
export function useAtomValue<Value>(atom: Atom<Value>, options?: Options) {
  const { delay, unstable_promiseStatus: promiseStatus = !React.use } =
    options || {}
  const store = useStore(options)

  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] =
    useReducer<readonly [Value, Store, typeof atom], undefined, []>(
      (prev) => {
        const nextValue = store.get(atom)
        if (
          Object.is(prev[0], nextValue) &&
          prev[1] === store &&
          prev[2] === atom
        ) {
          return prev
        }
        return [nextValue, store, atom]
      },
      undefined,
      () => [store.get(atom), store, atom],
    )

  let value = valueFromReducer
  if (storeFromReducer !== store || atomFromReducer !== atom) {
    rerender()
    value = store.get(atom)
  }

  useEffect(() => {
    const unsub = store.sub(atom, () => {
      if (typeof delay === 'number') {
        setTimeout(rerender, delay)
        return
      }
      rerender()
    })
    rerender()
    return unsub
  }, [store, atom, delay, promiseStatus])

  useDebugValue(value)
  if (isPromiseLike(value)) {
    const promise = createContinuablePromise(value, () => store.get(atom))
    return use(promise)
  }
  return value as Awaited<Value>
}
```

핵심은 세 가지이다:
1. `useReducer`의 reducer가 `Object.is`로 값을 비교하여 동일하면 이전 상태를 반환 → 불필요한 리렌더링 방지
2. `useEffect`에서 `store.sub(atom, rerender)`로 구독하여 atom 변경 시 reducer를 트리거
3. 반환값이 Promise면 `createContinuablePromise`로 감싸서 `use()`에 전달 → Suspense 통합

`useSetAtom`은 값을 구독하지 않고 setter만 반환한다. atom 값이 변경되어도 이 훅을 사용하는 컴포넌트는 리렌더되지 않는다:

```ts
// [focus:6-8]
export function useSetAtom<Value, Args extends unknown[], Result>(
  atom: WritableAtom<Value, Args, Result>,
  options?: Options,
) {
  const store = useStore(options)
  const setAtom = useCallback(
    (...args: Args) => store.set(atom, ...args),
    [store, atom],
  )
  return setAtom
}
```

## 9. 비동기 atom — Promise, Abort, Suspense

비동기 atom의 전체 흐름은 크게 3단계로 나뉜다: (1) Store에서 Promise를 값으로 저장하고 abort를 관리하는 단계, (2) React에서 Promise를 Suspense 가능한 형태로 변환하는 단계, (3) 의존성이 바뀌어 재계산될 때 이전 Promise를 abort하고 새 Promise로 이어가는 단계이다.

### 9.1 Store 측: promiseStateMap과 abort 메커니즘

`promiseStateMap`은 `WeakMap<PromiseLike, [pending: boolean, abortHandlers: Set]>`로, Promise의 pending 여부와 abort 핸들러 목록을 추적한다:

```ts
// [focus:3-5,10-11,16,21-23]
// vanilla/internals.ts
const promiseStateMap: WeakMap<
  PromiseLike<unknown>,
  [pending: boolean, abortHandlers: Set<() => void>]
> = new WeakMap()

function registerAbortHandler(promise, abortHandler) {
  let promiseState = promiseStateMap.get(promise)
  if (!promiseState) {
    promiseState = [true, new Set()]
    promiseStateMap.set(promise, promiseState)
    const settle = () => { promiseState![0] = false }
    promise.then(settle, settle)  // resolve/reject 시 pending = false
  }
  promiseState[1].add(abortHandler)
}

function abortPromise(promise) {
  const promiseState = promiseStateMap.get(promise)
  if (promiseState?.[0]) {           // pending 상태일 때만
    promiseState[0] = false          // pending 해제
    promiseState[1].forEach((fn) => fn())  // 모든 abort 핸들러 실행
  }
}
```

`readAtomState`에서 비동기 atom의 `read`가 Promise를 반환하면, AbortController를 lazy하게 생성하고 해당 Promise에 abort 핸들러를 등록한다:

```ts
// [focus:4-6,11-14]
// readAtomState 내부
let controller: AbortController | undefined
const options = {
  get signal() {
    if (!controller) controller = new AbortController()
    return controller.signal
  },
}
// ...
const valueOrPromise = atomRead(store, atom, getter, options)
setAtomStateValueOrPromise(store, atom, valueOrPromise)
if (isPromiseLike(valueOrPromise)) {
  registerAbortHandler(valueOrPromise, () => controller?.abort())
}
```

`setAtomStateValueOrPromise`에서 값이 교체될 때, 이전 값이 Promise이고 새 값과 다르면 `abortPromise(prevValue)`가 호출된다:

```ts
// [focus:4-8]
// setAtomStateValueOrPromise
atomState.v = valueOrPromise
delete atomState.e
if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
  ++atomState.n
  if (isPromiseLike(prevValue)) {
    abortPromise(prevValue)  // 이전 Promise abort → controller.abort() 실행
  }
}
```

즉, 의존성이 바뀌어 `readAtomState`가 다시 호출되면: 새 Promise가 `atomState.v`에 저장 → 이전 Promise가 abort → 이전 Promise의 AbortController에 signal 발생 → atom의 `read` 함수에서 `signal.aborted`로 이를 감지할 수 있다.

### 9.2 React 측: continuablePromise와 Suspense 트리거

`useAtomValue`에서 `store.get(atom)`의 반환값이 Promise면, 그대로 `React.use()`에 넘기는 것이 아니라 `createContinuablePromise`로 한번 감싼다:

```ts
// react/useAtomValue.ts
if (isPromiseLike(value)) {
  const promise = createContinuablePromise(value, () => store.get(atom))
  return use(promise)  // React.use() 또는 throw promise (shim)
}
```

`use()`의 shim 구현은 React 19 이전에서 Suspense를 트리거한다:

```ts
// [focus:3,10-11]
const use = React.use || ((promise) => {
  if (promise.status === 'pending') {
    throw promise    // ← Suspense 트리거: React가 이 throw를 잡아 fallback 렌더링
  } else if (promise.status === 'fulfilled') {
    return promise.value
  } else if (promise.status === 'rejected') {
    throw promise.reason
  } else {
    attachPromiseStatus(promise)
    throw promise    // 첫 호출 시에도 throw
  }
})
```

`attachPromiseStatus`는 Promise 객체에 `.status`, `.value`, `.reason` 프로퍼티를 추가하여 `use()`가 동기적으로 상태를 확인할 수 있게 한다:

```ts
const attachPromiseStatus = (promise) => {
  if (!promise.status) {
    promise.status = 'pending'
    promise.then(
      (v) => { promise.status = 'fulfilled'; promise.value = v },
      (e) => { promise.status = 'rejected'; promise.reason = e },
    )
  }
}
```

### 9.3 continuablePromise — 값이 바뀌어도 같은 Promise 유지

`createContinuablePromise`가 핵심이다. 이 함수는 원본 Promise를 감싸는 **단일 wrapper Promise**를 만들고, abort가 발생하면 내부적으로 새 Promise로 교체한다. React에게는 같은 Promise 객체를 유지하므로 불필요한 Suspense 재트리거를 방지한다:

```ts
// [focus:9-17,23-24]
const createContinuablePromise = (promise, getValue) => {
  let continuablePromise = continuablePromiseMap.get(promise)
  if (!continuablePromise) {
    continuablePromise = new Promise((resolve, reject) => {
      let curr = promise
      const onFulfilled = (me) => (v) => { if (curr === me) resolve(v) }
      const onRejected = (me) => (e) => { if (curr === me) reject(e) }
      const onAbort = () => {
        try {
          const nextValue = getValue()      // store.get(atom) 재호출
          if (isPromiseLike(nextValue)) {
            continuablePromiseMap.set(nextValue, continuablePromise!)
            curr = nextValue                 // 새 Promise로 교체
            nextValue.then(onFulfilled(nextValue), onRejected(nextValue))
            registerAbortHandler(nextValue, onAbort)  // 다음 abort도 대비
          } else {
            resolve(nextValue)               // 동기 값이면 즉시 resolve
          }
        } catch (e) {
          reject(e)
        }
      }
      promise.then(onFulfilled(promise), onRejected(promise))
      registerAbortHandler(promise, onAbort)
    })
    continuablePromiseMap.set(promise, continuablePromise)
  }
  return continuablePromise
}
```

전체 흐름을 순서대로 정리하면:

1. 비동기 atom `A`의 `read`가 Promise P1을 반환
2. `atomState.v = P1`, `registerAbortHandler(P1, () => controller.abort())`
3. `useAtomValue`에서 `createContinuablePromise(P1, () => store.get(A))` → wrapper Promise W 생성
4. `use(W)` → W는 pending이므로 `throw W` → **Suspense fallback 렌더링**
5. A의 의존성이 변경됨 → `readAtomState(A)` 재호출 → 새 Promise P2 반환
6. `setAtomStateValueOrPromise`에서 `atomState.v = P2`, `Object.is(P1, P2)` → false → `abortPromise(P1)` 실행
7. P1의 abort 핸들러 실행 → controller.abort() (atom의 read에서 signal.aborted 감지 가능)
8. continuablePromise의 `onAbort` 실행 → `getValue()` = `store.get(A)` → P2 반환
9. `curr = P2`, `P2.then(...)` 등록 — **wrapper Promise W는 동일 객체를 유지**
10. P2가 resolve되면 → W도 resolve → `use(W)`가 값 반환 → **컴포넌트 렌더링**

`continuablePromiseMap`은 `WeakMap`이므로 Promise가 GC되면 매핑도 자동 정리된다. 또한 `useEffect`의 subscriber에서도 Promise 상태를 갱신한다:

```ts
useEffect(() => {
  const unsub = store.sub(atom, () => {
    if (promiseStatus) {
      try {
        const value = store.get(atom)
        if (isPromiseLike(value)) {
          attachPromiseStatus(
            createContinuablePromise(value, () => store.get(atom)),
          )
        }
      } catch { /* ignore */ }
    }
    rerender()
  })
  // ...
}, [store, atom, delay, promiseStatus])
```

atom 값이 변경될 때마다 subscriber가 호출되고, Promise인 경우 `attachPromiseStatus`로 `.status`를 갱신한 뒤 `rerender()`로 React에게 재평가를 요청한다.

## 10. 정리

Jotai v2.17.1의 핵심 메커니즘을 요약하면 다음과 같다:

- **atom은 설정 객체**이다. 상태는 Store의 WeakMap에 저장된다.
- **epoch 기반 변경 감지**: `Object.is` 비교 후 epoch(`n`)을 증가시켜 변경을 추적한다.
- **자동 의존성 수집**: `read` 함수의 getter 호출 시 `atomState.d`에 의존성과 epoch를 기록한다.
- **Write 전파**: DFS로 의존자를 invalidate하고, 위상 정렬 순서로 재계산한다.
- **Mount/Unmount**: 구독자가 있는 atom만 마운트되며, WeakMap 기반으로 GC가 자연스럽게 동작한다.
- **React 통합**: `useReducer` + `store.sub`로 구독하고, `Object.is`로 불필요한 리렌더링을 방지한다.
- **비동기**: `promiseStateMap`으로 Promise 상태를 추적하고, continuablePromise로 Suspense와 통합한다.
- **BuildingBlocks 25슬롯 튜플**: 모든 내부 함수를 교체 가능하게 설계하여 확장성을 제공한다.
